= SHOCO v2.1 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:!sectnums:
:imagesDir: images
:xrefstyle: full
:repoURL: https://github.com/AY1920S2-CS2113T-T13-1/tp/tree/master

By: `Team SHOCOTech`      Since: `Mar 2020`

== 1. Introduction

[[Introduction-Purpose]]
=== Purpose of this guide

This guide describes the software architecture and design of the SHOCO application.
It will evolve throughout the design and implementation of each SHOCO release.
Currently, this document is for the third public release of the application, SHOCO v2.1.

[[Introduction-Scope]]
=== Scope of this guide

This document describes the software architecture and design for the implementation of SHOCO and is tailored for the developers, designers, and software testers of SHOCO.

&nbsp;

+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++ &nbsp;

== 2. Overview of the SHOCO application

The overview of the main classes in the application are shown in the class diagram below.
Omitted are the classes for the features implemented, the `LoadData` class, `WriteData` class, `FileUtil` class and `CommandLineTable` class.

image::ClassDiagramFinal.png[]

// @@author kokjoon97

The `Duke` class manages all required resources in the execution of the application.
These include a `ShoppingList` object to keep track of the `Item` objects the user has added to his list and a `Budget` object to store the user's budget.

`Duke` also has a `Storage` object for saving and loading data from memory - this data includes the latest saved `ShoppingList` and `Budget`.

There is a dependency from `Duke` to `Parser` as it only creates an instance of the `Parser` every time user input is received by the `Ui` and does not keep track of the `Parser` which is deleted after it is done parsing the current user input.
The `Parser` determines what command is being invoked by the user before creating a new `Command` object.
It then returns the reference to the new `Command` object  to `Duke`.

At any point in time, `Duke` only stores up to one `Command` and no more.
This `Command` has to be executed before `Duke` can receive more user input.
// @@author
&nbsp;

+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++ &nbsp;

== 3. Implementation

This section will describe how the main features of the application are implemented.

// tag::Add[]
=== 3.1 Add feature

==== 3.1.1 Current implementation

The add feature is implemented using an `AddCommand` class.
This class extends from the main  `Command` class.
The user input *must contain at least a description* out of these parameters:   _description_, _price_, _quantity_.
User can choose not to input price or quantity as the price will set to   default which is 0.0 if the user did not input any value for price.
On the other hand, quantity will set to   default which is 1 if the user did not input any value for quantity.

Process of object creation:

. `Duke` class receives user input from the `Ui` class.
. A `Parser` object is created to call its `parseCommand` method.
 ** The `Parser` object instantiates an `AddCommand` object based on the user input.
. The `Duke` class calls the `AddCommand#execute` method of the `AddCommand` object.
. In the `AddCommand#execute` function, the `item` to be add is called from the `ShoppingList`  object, using items.add().
. In the SD, the AddCommand will add `item` if the description is provided and one / both price and  quantity is provided.
. The `item` object with its' values is stored into the `ShoppingList` object.

The following sequence diagram below shows how the add feature works.
The details of the adding item's values  are shown in a separate sequence diagram below:

image::AddFeature.png[]

image::AddFeature_SD.png[]

==== 3.1.2 Design considerations

===== Aspect: Data structure to support the add feature

* Alternative 1 (current choice): User must provided a description for item, Duplicates are                                 not allowed in the list.
 ** Pros: User has minimal potential to see unreasonable list in the Shopping List.
For  example, having a item that has only price and quantity but without description and also a list that one item is recorded multiple times in the list.
 ** Cons: Will significantly increase the code base as there is a need to check for the  presence of the variable in user input to avoid duplication, not human friendly in certain  scenario (eg: user wants to have duplicates because the item is for different occasion and  the user wants to record down twice without any elaboration).
* Alternative 2: Require user to provide all three values to successfully add the item into                 the list.
Duplicates are allowed
 ** Pros: User will have a neat and unity Shopping list, less deal with parameter (because users are forced to give all three variables).
And the duplicates item are useful in certain specific condition.
 ** Cons: User flexibility will decrease, because user must input all parameters even if he/she does not want to  provide certain variables such as price and quantity, which will result unsuccessful adding items into the list.
Also, duplicate items may confused the user, even though in some specific scenario, duplicate item may be useful to  the user.

Reasons for choosing Alternative 1 over alternative 2: By allowing user to just add the item without price,  we can increase the flexibility.
For instance, the user wants to buy milk but not sure how much does the milk  cost and not sure how many milk they want to buy.
So they can just add it into the list,  and edit the price and quantity later when they knew the price and have decided the quantity.

// end::Add[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;


// @@author trishaangelica
// tag::Edit[]
=== 3.2 Edit feature

==== 3.2.1 Current implementation

The edit feature is implemented using an `EditCommand` class.
This class extends from the main `Command` class.
The `item` object to be edited is identified by the index number provided  in the user input.
In addition to the index no.
, the user input *must also contain at least one* of these parameters:  _description_, _price_, _quantity_.

The process of object creation is as follows:

. `Duke` class receives user input from the `Ui` class.
. A `Parser` object is created to call its `parseCommand` method.
 ** The `Parser` object instantiates an `EditCommand` object based on the user input.
. The `Duke` class calls the `EditCommand#execute` method.
. In the `EditCommand#execute` method, it first gets the `item` object through the `ShoppingList#getItem` The original description/price/quantity of the item is overwritten  with the new values from the user input.
This is done through the use of the `Item` class setter methods.
. The `item` object with its' new values is stored back to the `ShoppingList` object.

The following sequence diagram below shows how the edit feature works.
The details of updating the items' values have been omitted from the diagram.
Those details are shown in a separate sequence diagram below:

image::EditFeature.png[]

image::EditFeature_SD.png[]

==== 3.2.2 Design considerations

===== Aspect: Data structure to support the edit feature

* Alternative 1 (current choice): Only parameters present in user input are treated as values to update.
 ** Pros: User has the flexibility to choose which variables he/she wishes to update.
 ** Cons: Might significantly increase the code base as there is a need to check for the  presence of the variable in user input.
* Alternative 2: Require all values of an `item` object to be updated and parameters must be in alphabetical order.
 ** Pros: Will have less code to deal with having no additional parsing of the input string.
 ** Cons: Less user flexibility;
user must input all parameters even if he/she does not wish to update certain variables.
* Reason for choosing alternative 1: By allowing users to be able to update any values they want, it provides them with greater convenience and freedom as they do not need to follow strict command "rules/order".
Futhermore, having greater freedom on input values makes it a hassle-free process for the users.

// end::Edit[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++
// @@author

&nbsp;



// @@author kokjoon97
// tag::Delete[]
=== 3.3 Delete feature

==== 3.3.1 Current implementation

The delete feature is implemented using a `DeleteCommand` class which extends the main `Command` class with an index representing that of the item to be deleted from the shopping list.

The process is as follows:

. `Duke` receives user input from `Ui`.
. `Duke` calls `Parser#parseCommand()` to instantiate a `DeleteCommand` object based on that user input.
. `Duke` then calls `DeleteCommand#execute()`.
. `DeleteCommand#execute()` makes another call to `ShoppingList#deleteItem()`.
. The `Item` at the specified index is then removed from the `ShoppingList` object.

The following sequence diagram below shows how the delete feature works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::Deletefinal2.png[]

==== 3.3.2 Design considerations

===== Aspect: Data structure to support the delete feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `DeleteCommand`
 ** Pros: Easy to add the delete feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement delete feature in the `Duke` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details
* Reason for choosing alternative 1: By abstracting out different command types as separate classes, this allowed us to work better in parallel and also be able to spot bugs more easily as each class deals with a different functionality.

// end::Delete[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;



// tag::Find[]
=== 3.4 Find feature

==== 3.4.1 Current implementation

The find feature is implemented using a `FindCommand` class which extends the main `Command` class with a String representing the keyword specified by the user.

The process is as follows:

. `Duke` receives user input from `Ui`.
. `Duke` calls `Parser#parseCommand()` to instantiate a `FindCommand` object based on that user input.
. `Duke` then calls `FindCommand#execute()`.
. `FindCommand#execute()` makes various calls to `ShoppingList#getItem()` to check whether the `Item` at each specified index contains the given keyword.
. Each `Item` that contains the keyword is then added to a new `ArrayList` named  `filteredItems` that is maintained by the `FindCommand` object.
. This list of matching results is then printed to standard output.

The following sequence diagram below shows how the `Duke` object creates the `FindCommand` object.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::Findfinal2.png[]

This next sequence diagram will show how the `FindCommand` creates the `filteredItems` list:

image::Finditemsfinal2.png[]

==== 3.4.2 Design considerations

===== Aspect: Data structure to support the find feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `FindCommand`
 ** Pros: Easy to add the find feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement find feature in the `Duke` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details
* Reason for choosing alternative 1: With each command type having its own class, we could work better in parallel and also be able to trace functionality bugs more easily if each command class deals with a different functionality.
// @@author

// end::Find[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;



// tag::MarkAndUnmark[]
=== 3.5 Mark and Unmark feature

==== 3.5.1 Current Implementation

The mark and unmark feature is implemented using the `MarkCommand` and `UnmarkCommand` class  which extends the main `Command` class with an index representing that of the item to be marked or  unmarked as bought in the list.

The process of object creation:

. The `Duke` class first receives user input from the `Ui`
. The `Duke` class then creates a `Parser` object and calls its `parseCommand` method  to instantiate a `MarkCommand` or `UnmarkCommand` object based on the user input
. The `Duke` class then calls the `execute` method of the `MarkCommand` or   `UnmarkCommand` command object.
This calls the `markAsBought` or `unmarkAsBought`  method of the `shoppingList` object with the specified index.

The following sequence diagram below shows how the Mark feature (Diagram 1) and Unmark feature (Diagram 2) works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

Diagram 1:

image::Mark.png[]

Diagram 2:

image::Unmark.png[]

==== 3.5.2 Design Considerations

===== Aspect: Data structure to support the Mark and Unmark Feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `MarkCommand`   and `UnmarkCommand`
 ** Pros: Easy to edit and add the mark and unmark feature without having to change the logic of the code in  multiple files
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement the mark and unmark feature in either the `Duke` or `Parser` class
 ** Pros: Will have less code and classes to deal with, without having to create a whole new object to execute the command.
 ** Cons: Code becomes harder to navigate and understand since the command is all handled under one class, thus makes having to edit the mark and unmark feature difficult.

// end::MarkAndUnmark[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;



// tag::Display[]
=== 3.6 Display feature

This feature involves displaying the shopping list and budget details to the user.

==== 3.6.1 Current implementation

The display feature is implemented using a `DisplayCommand` class which extends the `Command`  class.

The `Duke` class first receives user input from the `Ui` object before it creates a  `Parser` object and calls its `parseCommand` function to instantiate a  `DisplayCommand` object based on that user input.

The `Duke` class then calls the `execute` method of the `DisplayCommand` object.
This method makes a call to the `getTotalCost` method of the `ShoppingList` object to find the  cost of the items.
It then calls the `getAmount` and `getRemainingBudget` methods of the  `Budget` object to find the current budget and the remaining budget.
The results are then printed to console.

The following sequence diagrams below show how the display feature works.
Note the `Ui` class is omitted to emphasise the other classes:

image::Display.png[]

image::Display_SD.png[]

==== 3.6.2 Design considerations

===== Aspect: Data structure to support the display feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `DisplayCommand`
 ** Pros: Easy to add the display feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement display feature in the `Duke` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Handling the command under the `Duke` class results in longer methods.
Thus, the code becomes  harder to navigate and understand.

// end::Display[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;



// tag::Clear[]
=== 3.7 Clear list feature

This feature involves clearing all items in the shopping list.
Remaining budget is also set to the user's set budget.

==== 3.7.1 Current implementation

The clear list feature is implemented using a `ClearCommand` class which extends the `Command`  class.

The `Duke` class first receives user input from the `Ui` object before it creates a  `Parser` object and calls its `parseCommand` function to instantiate a  `ClearCommand` object based on that user input.

The `Duke` class then calls the `execute` method of the `ClearCommand` object which  makes another call to the `clearList` method of the `ShoppingList` object.

The following sequence diagram below shows how the clear list feature works.
Note the `Ui` class is omitted to emphasise the other classes:

image::Clear.png[]

==== 3.7.2 Design considerations

===== Aspect: Data structure to support the clear list feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `ClearCommand`
 ** Pros: Easy to add the clear list feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement clear list feature in the `Duke` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Handling the command under the `Duke` class results in longer methods.
Thus, the code becomes  harder to navigate and understand.

// end::Clear[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;


// @@author kokjoon97
// tag::SetBudget[]
=== 3.8 Set budget feature

==== 3.8.1 Current implementation

The set budget feature is implemented using a `SetBudgetCommand` class which extends the main `Command` class with a variable representing the budget amount.

The process is as follows:

. `Duke` receives user input from `Ui`.
. `Duke` calls `Parser#parseCommand()` to instantiate a `SetBudgetCommand` object based on that user input.
. `Duke` then calls `SetBudgetCommand#execute()`.
. `SetBudgetCommand#execute()` makes another call to `Budget#setBudget()`.
. The amount in the `Budget` object is set to the amount specified by the user.

The following sequence diagram below shows how the set budget feature works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::Setfinal2.png[]

==== 3.8.2 Design considerations

===== Aspect: Data structure to support the set budget feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `SetBudgetCommand`
 ** Pros: Easy to add the set budget feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement set budget feature in the `Duke` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details
* Reason for choosing alternative 1: By implementing each command type in a separate class, any bugs associated with a particular functionality will not affect other functionalities that significantly.
It would also make it easier for us to  work in parallel.
// @@author

// end::SetBudget[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;


// tag::ResetBudget[]
=== 3.9 Reset budget feature

==== 3.9.1 Current implementation

The reset budget feature is implemented using a `ResetBudgetCommand` class which extends the main `Command` class with a variable representing the budget amount.

The `Duke` class first receives user input from the `Ui` class before it creates a  `Parser` object and calls its `parseCommand` function to instantiate a  `ResetBudgetCommand` object based on that user input.

The `Duke` class then calls the `execute` method of the `ResetBudgetCommand` object which makes another call to the `resetBudget` function of the `Budget` object.

The following sequence diagram below shows how the reset budget feature works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::Reset_Budget.png[]

==== 3.9.2 Design considerations

===== Aspect: Data structure to support the reset budget feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `ResetBudgetCommand`
 ** Pros: Easy to add the reset budget feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement reset budget feature in the `Duke` or `Parser` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details

// end::ResetBudget[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;




// @@author trishaangelica
// tag::Help[]
=== 3.10 View help feature

==== 3.10.1 Current implementation

The help feature is implemented using a `HelpCommand` class which extends the main `Command` class.
The `HelpCommand` class shows the program usage instructions to the user.

The `Duke` class first receives user input from the `Ui` class before it creates a  `Parser` object and calls its `parseCommand` function.
If the user input fails to match any of the correct command keywords (`ADD`, `EDIT`, `DEL` etc.), a  `HelpCommand` object will be instantiated.

Once instantiated, the `Duke` then class calls the `execute` method of the  `HelpCommand` object.
In this method, accepted command formats are displayed to the user.

The following sequence diagram below shows how the help feature works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::HelpFeature.png[]

==== 3.10.2 Design considerations

===== Aspect: Data structure to support the help feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `HelpCommand`
 ** Pros: Easy to add the help feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement help feature in the `Duke` or `Parser` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details

// end::Help[]

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;

// @@author
// tag::Exit[]
=== 3.11 Exit program feature

==== 3.11.1 Current implementation

The program termination feature is implemented using a `ExitCommand` class which extends the main `Command` class.
The `ExitCommand` class terminates the program when instantiated.

The `Duke` class first receives user input from the `Ui` class before it creates a  `Parser` object and calls its `parseCommand` function.
If the user input matches the exit command keyword: `"BYE"`, a `HelpCommand` object will be instantiated.

Once instantiated, the `Duke` then class calls the `execute` method of the  `Exit Command` object.
In this method, the program is terminated.

The following sequence diagram below shows how the help feature works.
Note the `Ui` class is omitted in the sequence diagram to emphasise on the other classes:

image::ExitFeature.png[]

==== 3.11.2 Design considerations

===== Aspect: Data structure to support the exit feature

* Alternative 1 (current choice): Object-oriented style with a separate class for `ExitCommand`
 ** Pros: Easy to add the exit feature without having to change the logic of the code much as each command object is treated as a black box
 ** Cons: Might significantly increase the code base with another class being added
* Alternative 2: Implement exit feature in the `Duke` or `Parser` class
 ** Pros: Will have less code to deal with as a new function is simply created in the `Duke` class
 ** Cons: Code becomes less organised since for every other command that we have implemented, `Duke` class simply executes those commands as black boxes, without worrying about their internal details

// end::Exit[]
&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;

// @@author kokjoon97

== Appendix A: Product Scope

This section talks about who this product targets and what it aims to achieve.

=== Target user profile

* Likes to cook at home and requires help keeping track of complex grocery shopping lists and staying within budget
* Prefers to use command line interface applications as opposed to other kinds of applications or paper
* Can type fast

=== Value proposition

* Make grocery shopping a breeze by offering greater flexibility in managing shopping lists and also providing helpful features like budget tracking
// @@author

&nbsp;

+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;

== Appendix B: User Stories

This section contains the user stories for the different versions of our product.

|===
| Version | As a ... | I want to ... | So that I can ...

| v1.0
| organised home cook
| be able to edit my budget
| change my budget when I need to

| v1.0
| organised home cook
| delete items from the list
| manage my list

| v1.0
| organised home cook
| have a useful "help" list that I can refer to
| find instructions for various commands

| v1.0
| frugal home cook
| add a budget
| so that I know how much I have to spend

| v1.0
| organised home cook
| mark things as bought
| keep track of my grocery progress

| v1.0
| frugal home cook
| be able to clear my budget
| set a new budget

| v1.0
| frugal home cook
| be able to see the total value of the items in my shopping list
| know that I am within budget

| v1.0
| frugal home cook
| see the remaining budget that I have left
| avoid exceeding my budget

| v1.0
| practical home cook
| be able to clear all items from the list with one command
| easily start off with a clean slate

| v1.0
| practical home cook
| see all items on my list
| see at a glance what I have planned to buy

| v1.0
| frugal home cook
| see my budget
| know if I'm within or out of my budget

| v1.0
| frugal home cook
| calculate my remaining budget
| see how much I have left to spend

| v2.0
| frugal home cook
| be notified when I cross my budget
| remove some items from my list

| v2.0
| practical home cook
| be able to search for items on my list
| find things easily in a long list

| v2.0
| practical home cook
| be able to edit the items in my lists
| update the items on my list accordingly

| v2.0
| organised home cook
| save my list
| have a local copy of my list

| v2.0
| organised home cook
| load my saved list
| add on to my existing list

| v2.0
| frugal home cook
| see the remaining budget update based on the quantity of items
| see how much I spend based on how much I buy
|===

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;
// @@author kokjoon97

== Appendix C: Non-Functional Requirements

. Should work on any OS that has Java 11 or later installed.
. Should respond to any user commands within 2 seconds.
. Should be easy to use even for people who have never used a command line interface before.
// @@author

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;

== Appendix D: Glossary

* _glossary item_ - Definition

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;

== Appendix E: Instructions for Manual Testing

{Give instructions on how to do a manual product testing e.g., how to load sample data to be used for testing}

&nbsp;
+++<b>+++<<shoco-v21---developer-guide,&#129053;
back to top>>+++</b>+++

&nbsp;
